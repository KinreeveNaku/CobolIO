/**
 * 
 */
package com.github.cobolio.internal.compiler;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.Writer;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import javax.xml.bind.JAXB;

import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.app.VelocityEngine;

import com.github.cobolio.CobolSchema;
import com.github.cobolio.internal.cobol.datatype.ExternalDecimal;
import com.github.cobolio.internal.cobol.datatype.PackedDecimal;
import com.github.cobolio.internal.cobol.datatype.UnicodeDecimal;
import com.github.cobolio.internal.xml.cb2xml.Copybook;
import com.github.cobolio.internal.xml.cb2xml.EnhancedCopybook;

import net.sf.cb2xml.Cb2Xml;

/**
 * @author Andrew
 *
 */
public class CobolIOCompiler {
	private static final int JVM_METHOD_ARG_LIMIT = 255;

	public enum FieldVisibility {
		PUBLIC, PUBLIC_DEPRECATED, PRIVATE;
	}

	public enum PrimitiveTypes {
		STRING, INTEGER, DOUBLE,
	}

	private VelocityEngine velocityEngine;
	private String templateDir;
	private FieldVisibility fieldVisibility = FieldVisibility.PRIVATE;
	private boolean createOptionalGetters = false;
	private boolean gettersReturnOptional = false;
	private boolean createSetters = true;
	private boolean createAllArgsConstructor = true;
	private String outputCharacterEncoding;
	private String suffix = ".java";

	private static final String FILE_HEADER = "/**\n" + " * Autogenerated by CobolIO\n" + " *\n"
			+ " * DO NOT EDIT DIRECTLY\n" + " */\n";

	public CobolIOCompiler(CobolSchema schema) {
		enqueue(schema);
	}

	/**
	 * Set the resource directory where templates reside. First, the compiler checks
	 * the system path for the specified file, if not it is assumed that it is
	 * present on the classpath.
	 */
	public void setTemplateDir(String templateDir) {
		this.templateDir = templateDir;
	}

	/** Set the resource file suffix, .java or .xxx */
	public void setSuffix(String suffix) {
		this.suffix = suffix;
	}

	/**
	 * @return true if the record fields should be marked as deprecated
	 */
	public boolean deprecatedFields() {
		return (this.fieldVisibility == FieldVisibility.PUBLIC_DEPRECATED);
	}

	/**
	 * @return true if the record fields should be public
	 */
	public boolean publicFields() {
		return (this.fieldVisibility == FieldVisibility.PUBLIC
				|| this.fieldVisibility == FieldVisibility.PUBLIC_DEPRECATED);
	}

	/**
	 * @return true if the record fields should be private
	 */
	public boolean privateFields() {
		return (this.fieldVisibility == FieldVisibility.PRIVATE);
	}

	/**
	 * Sets the field visibility option.
	 */
	public void setFieldVisibility(FieldVisibility fieldVisibility) {
		this.fieldVisibility = fieldVisibility;
	}

	public boolean isCreateSetters() {
		return this.createSetters;
	}

	/**
	 * Set to false to not create setter methods for the fields of the record.
	 */
	public void setCreateSetters(boolean createSetters) {
		this.createSetters = createSetters;
	}

	public boolean isCreateOptionalGetters() {
		return this.createOptionalGetters;
	}

	/**
	 * Set to false to not create the getters that return an Optional.
	 */
	public void setCreateOptionalGetters(boolean createOptionalGetters) {
		this.createOptionalGetters = createOptionalGetters;
	}

	public boolean isGettersReturnOptional() {
		return this.gettersReturnOptional;
	}

	/**
	 * Set to false to not create the getters that return an Optional.
	 */
	public void setGettersReturnOptional(boolean gettersReturnOptional) {
		this.gettersReturnOptional = gettersReturnOptional;
	}

	private void enqueue(CobolSchema schema) {
		// TODO finish build queueing
	}

	/**
	 * Temporary structure that extends the Map interface for storing context information.
	 * May be altered or removed in the future. Currently for ease of use.
	 * @author Andrew
	 *
	 */
	static final class InternalContext implements Map<String, Object> {
		
		private final LinkedHashMap<String, Object> reference;
		/**
		 * 
		 */
		private static final String CREATE_SETTERS = "createSetters";
		/**
		 * 
		 */
		private static final String GETTERS_RETURN_OPTIONAL = "gettersReturnOptional";
		/**
		 * 
		 */
		private static final String IMPORTS = "imports";
		
		private static final String FIELD_VISIBILITY = "fieldVisibility";
		
		private static final String CONTEXT_CLASS_NAME = "className";

		public InternalContext(String contextClass) {
			this.reference = new LinkedHashMap<String, Object>();
			this.put(CONTEXT_CLASS_NAME, contextClass);
			this.put(IMPORTS, new LinkedHashSet<Class<?>>());
		}

		@Override
		public int size() {
			return this.reference.size();
		}

		@Override
		public boolean isEmpty() {
			return this.reference.isEmpty();
		}

		@Override
		public boolean containsKey(Object key) {
			return this.reference.containsKey(key);
		}

		@Override
		public boolean containsValue(Object value) {
			return this.reference.containsValue(value);
		}

		@Override
		public Object get(Object key) {
			return this.reference.get(key);
		}

		@Override
		public Object put(String key, Object value) {
			return this.reference.put(key, value);
		}

		@Override
		public Object remove(Object key) {
			return this.reference.remove(key);
		}

		@Override
		public void putAll(Map<? extends String, ? extends Object> m) {
			this.reference.putAll(m);
			
		}

		@Override
		public void clear() {
			throw new UnsupportedOperationException();
			
		}

		@Override
		public Set<String> keySet() {
			return this.reference.keySet();
		}

		@Override
		public Collection<Object> values() {
			return this.reference.values();
		}
		
		@Override
		public Set<Entry<String, Object>> entrySet() {
			return this.reference.entrySet();
		}

		public String getContextClass() {
			return (String) this.get(CONTEXT_CLASS_NAME);
		}
		
		/**
		 * 
		 * @implNote Must be LinkedHashSet for ordering.
		 * @param imports
		 */
		public void putImports(LinkedHashSet<Class<?>> imports) {
			((LinkedHashSet<Class<?>>) this.get(IMPORTS)).addAll(imports);
		}

		public void putCopybook(EnhancedCopybook cpy) {
			this.put("copybook", cpy);
		}

		// boolean variables
		/**
		 * For additional compatibility, {@link Optional} type getters can be created
		 * instead. This option sets all getter functions to return an Optional wrapper
		 * of the types.
		 * 
		 * @param isOptionalType
		 */
		public void createOptionalTypeGetters(boolean isOptionalType) {

		}
		
		public void setGettersReturnOptional(boolean isGettersReturnOptional) {
			this.put(GETTERS_RETURN_OPTIONAL, isGettersReturnOptional);
		}
		
		public void createSetters(boolean createSetters) {
			this.put(CREATE_SETTERS, createSetters);
		}
		
		public void setFieldVisibility(FieldVisibility fieldVisibility) {
			this.put(FIELD_VISIBILITY, fieldVisibility);
		}

		
	}
}
